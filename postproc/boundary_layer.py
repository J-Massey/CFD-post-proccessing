# -*- coding: utf-8 -*-"""@author: J. Massey@description: Module to hold all the various convergence tests for a series of simulations. This    will provide the tools to show that a simulation has converged.@contact: jmom1n15@soton.ac.uk"""# Importsimport numpy as npfrom multiprocessing import Poolimport matplotlib.pyplot as pltimport osimport torchimport mathfrom tqdm import tqdmdevice = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")def _interpolate(x, x0, x1, y0, y1):    """    Quickly interpolate between two points    Args:    Returns:        Linear interpolation    """    return y0 + (x - x0) * (y1 - y0) / (x1 - x0)def plot_poincare(x, y, file, x_label, y_label, title=None, alpha=0.15, color='red', colours=None, label=None):    ax = plt.gca()    fig = plt.gcf()    ax.set_title(title)    # Loop so that lines get darker when they overlap    for i in range(len(x) - 1):        ax.plot(x[i:i + 2], y[i:i + 2], alpha=alpha, color=color, solid_capstyle="butt")    ax.tick_params(bottom="on", top="on", right="on", which='both', direction='in', length=2)    # Edit frame, labels and legend    ax.set_xlabel(x_label)    ax.set_ylabel(y_label)    # Make legend manually so that we don'torch try and label each line segment    from matplotlib.lines import Line2D    legend_elements = []    for idx, loop in enumerate(label):        legend_elements.append(Line2D([0], [0], color=colours[idx], lw=4, label=loop))    ax.legend(handles=legend_elements, loc='lower right')    # Show plot and save figure    plt.savefig(file, transparent=False, bbox_inches='tight')    returnclass ProfileDataset:    """    This class takes an input of a convergence test directory and returns the resolution,    angle around the circle, a list of the velocities at discrete spacings. And the l1    distance between consecutive profiles.    For this class to work your simulation folders must be structured as:    |+-- vtr_file    |   +-- profiles    Where the profiles subdirectory will have been printed using the all_profiles function in    utils.f90. These should be printed as consecutive x and Y components e.g.:    ```    call all_profile(ave_v0%e(1), 256, 4.*length_scale, angle)    call all_profile(ave_v0%e(2), 256, 4.*length_scale, angle)    ```    """    def __init__(self, data_root, **kwargs):        self.profiles_folder = os.path.join(data_root, 'profiles')        self.conditions = []        self.step_angle = np.pi / len(os.listdir(self.profiles_folder))        self.print_res = kwargs.get('print_res', 128)        multi = kwargs.get('multi', 1)        self.profiles_x, self.profiles_y, self.angles = self.multip_profiles(os.listdir(self.profiles_folder), multi)    def _profiles(self, f_list):        profiles = []        for idx, angle in tqdm(enumerate(f_list), desc='Profile fn loop', ascii=True):            angle_file = os.path.join(self.profiles_folder, angle)            profile = np.genfromtxt(angle_file)            profiles.append(profile)        del profile        return np.stack(profiles, axis=0)    def multip_profiles(self, f_list, proc):        chunks = [f_list[i::proc] for i in range(proc)]        with Pool(processes=proc) as p:            if proc > 1:                result = np.concatenate(p.map(self._profiles, chunks))            else:                result = np.squeeze(p.map(self._profiles, chunks))        profiles_x = result[:, ::2, :]        profiles_y = result[:, ::2, :]        del result        angles = [(float(angle) - 1) * self.step_angle for angle in f_list]        return profiles_x, profiles_y, angles    def upstream(self, name, cutoff=np.pi / 2):        """        Function to extract the l1 distance between consecutive upstream profiles to ensure they have converged        in time and space. In future this could be much more clever and have a cut off when the flow has        separated.        """        tmp = []        for idx, ang in enumerate(self.angles):            if ang <= cutoff:                tmp.append(name[idx])        return tmp    def bl_value(self, single_point=True, position=0.1, length_scale=64, print_len=3):        """        Process the profile dat so the x and Y components of profiles either as single point in        that profile or as a sum of the whole BL        all the parts to encompass the whole profile.        :param single_point: Whether the BL should by analysed as a single point or an integral over the                            the whole profile.        :param position: The percentage of the diameter the BL profile is evaluated at        :param length_scale: The length scale of the simulation        :param print_len: How many length scales away from the body centre the profiles print.        :param print_res: How many points are printed when the print function is called        :return: PoincarÃ© limit cycle at different angles around the profile.        """        from collections import deque        # Length of points depending on the resolution chosen for the print function        len_print = self.print_res / print_len        # The ratio between the print resolution and the actual grid spacing        len_res = self.print_res / (print_len * length_scale)        # About where the smoothing region ends in terms of the print resolution        eps = 2 * len_res        if single_point:            # Check if the evaluation point is at least 3 grid cells from the body boundary            eval_point = position * len_print  # This is the distance away from the body in terms of the print res            if eval_point < eps * 1.1:                raise ValueError("The evaluation point sits too close to the smoothing region,\                                    try adjusting the 'position' or increase your resolution")            else:                radial = []                azimuthal = []                for idx_angle, (loop_angle_x, loop_angle_y) in enumerate(zip(self.profiles_x, self.profiles_y)):                    tmp_r = []                    tmp_a = []                    for loop_time_x, loop_time_y in zip(loop_angle_x, loop_angle_y):                        # Index to the profile list rounded away from boundary to avoid smoothing region                        idx = math.ceil(eval_point)  # Idx in terms of print res                        vel = np.array((loop_time_x[idx], loop_time_y[idx]))                        theta = self.angles[idx_angle]                        rot = np.array(((np.cos(theta), -np.sin(theta)),                                        (np.sin(theta), np.cos(theta))))                        # Do you need to scale the velocities by the length scale? Check means.                        rad, az = rot.dot(vel)                        tmp_r.append(rad)                        tmp_a.append(az)                    radial.append(tmp_r)                    azimuthal.append(tmp_a)                dim_r = []                dim_a = []                for idx, (r, a) in enumerate(zip(list(radial), list(azimuthal))):                    dim_r.append(np.shape(r))                    dim_a.append(np.shape(a))                reshaped_r = []                reshaped_a = []                for idx, (r, a) in enumerate(zip(radial, azimuthal)):                    r = np.array(r)                    a = np.array(a)                    reshaped_r.append(r[0:min(dim_r)[0]])                    reshaped_a.append(a[0:min(dim_a)[0]])            return np.array(reshaped_r), np.array(reshaped_a)        else:            radial = []            azimuthal = []            for idx_angle, (loop_angle_x, loop_angle_y) in enumerate(zip(self.profiles_x, self.profiles_y)):                tmp_r = np.array([])                tmp_a = np.array([])                for loop_time_x, loop_time_y in zip(loop_angle_x, loop_angle_y):                    vel = np.array((loop_time_x, loop_time_y))                    theta = self.angles[idx_angle]                    rot = np.array(((np.cos(theta), -np.sin(theta)),                                    (np.sin(theta), np.cos(theta))))                    rad, az = rot.dot(vel)                    tmp_r = np.append(tmp_r, rad)                    tmp_a = np.append(tmp_a, az)                radial.append(tmp_r)                azimuthal.append(tmp_a)            return radial, azimuthal    def get_u(self, p, length_scale=64, print_len=3, down=1):        """        Extracts the point velocity at a distance n away from the hard body boundary            p: Number of points away from the body boundary            length_scale: User defined resolution            print_len: How long the profile extends for in terms of length scale            down: A ratio to subsample the profile        Returns:            Point velocity p grid_cells from the boundary        """        # Find where the first point off the hard boundary is        ps = self.print_res / (print_len / down * length_scale)        u = np.empty(np.shape(self.profiles_x)[:-1])        v = np.empty(np.shape(self.profiles_y)[:-1])        n = (0.5 * length_scale + p) * ps + 1e-9        for idx_angle, (loop_angle_x, loop_angle_y) \                in enumerate(zip(self.profiles_x[:, :, ::down], self.profiles_y[:, :, ::down])):            for time, (loop_time_x, loop_time_y) in enumerate(zip(loop_angle_x, loop_angle_y)):                # Point on the edge of the smoothing region (still kinda corrupt from smoothing within)                # Not always printed on an index so interpolate between                u[idx_angle, time] = _interpolate(n, math.floor(n), math.ceil(n), loop_time_x[math.floor(n)],                                                  loop_time_x[math.ceil(n)])                v[idx_angle, time] = _interpolate(n, math.floor(n), math.ceil(n), loop_time_y[math.floor(n)],                                                  loop_time_y[math.ceil(n)])        return u, vif __name__ == "__main__":    data_root_ = '/home/masseyjmo/Workspace/Lotus/projects/cylinder_dns/data'    d = ProfileDataset(os.path.join(data_root_, '96'), multi=16)    print(np.shape(d))