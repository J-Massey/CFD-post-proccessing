# -*- coding: utf-8 -*-"""@author: J. Massey@description: Module to hold all the various convergence tests for a series of simulations. This    will provide the tools to show that a simulation has converged.@contact: jmom1n15@soton.ac.uk"""# Importsimport numpy as npfrom multiprocessing import Poolimport matplotlib.pyplot as pltimport osimport torchimport mathdevice = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")def _interpolate(x, x0, x1, y0, y1):    """    Quickly interpolate between two points    Args:        x:        x0:        x1:        y0:        y1:    Returns:        Linear interpolation    """    return y0 + (x - x0) * (y1 - y0) / (x1 - x0)def plot_poincare(x, y, file, x_label, y_label, title=None, alpha=0.15, color='red', colours=None, label=None):    ax = plt.gca()    fig = plt.gcf()    ax.set_title(title)    # Loop so that lines get darker when they overlap    for i in range(len(x) - 1):        ax.plot(x[i:i + 2], y[i:i + 2], alpha=alpha, color=color, solid_capstyle="butt")    ax.tick_params(bottom="on", top="on", right="on", which='both', direction='in', length=2)    # Edit frame, labels and legend    ax.set_xlabel(x_label)    ax.set_ylabel(y_label)    # Make legend manually so that we don't try and label each line segment    from matplotlib.lines import Line2D    legend_elements = []    for idx, loop in enumerate(label):        legend_elements.append(Line2D([0], [0], color=colours[idx], lw=4, label=loop))    ax.legend(handles=legend_elements, loc='lower right')    # Show plot and save figure    plt.savefig(file, transparent=False, bbox_inches='tight')    returnclass ProfileDataset:    """    This class takes an input of a convergence test directory and returns the resolution,    angle around the circle, a list of the velocities at discrete spacings. And the l1    distance between consecutive profiles.    For this class to work your simulation folders must be structured as:    |+-- vtr_file    |   +-- profiles    Where the profiles subdirectory will have been printed using the all_profiles function in    utils.f90. These should be printed as consecutive x and y components e.g.:    ```    call all_profile(ave_v0%e(1), 256, 4.*length_scale, angle)    call all_profile(ave_v0%e(2), 256, 4.*length_scale, angle)    ```    """    def __init__(self, data_root, multi=False):        self.profiles_folder = os.path.join(data_root, 'profiles')        self.conditions = []        self.step_angle = np.pi / len(os.listdir(self.profiles_folder))        if multi:            self.profiles_x, self.profiles_y, self.angles = self.multip_profiles(os.listdir(self.profiles_folder), 5)        else:            self.profiles_x, self.profiles_y, self.angles = self._profiles(os.listdir(self.profiles_folder))    def _profiles(self, f_list):        profiles_x = []        profiles_y = []        angles = []        for angle in f_list:            angle_file = os.path.join(self.profiles_folder, angle)            profile = np.genfromtxt(angle_file)            theta = (float(angle) - 1) * self.step_angle            profiles_x.append(profile[::2])            profiles_y.append(profile[1::2])            angles.append(theta)        return profiles_x, profiles_y, angles    def multip_profiles(self, f_list, proc):        chunks = [f_list[i::proc] for i in range(proc)]        pool = Pool(processes=proc)        result = pool.map(self._profiles, chunks)        profiles_x = []        profiles_y = []        angles = []        for i in result:            profiles_x.append(i[0])            profiles_y.append(i[1])            angles.append(i[2])        return np.squeeze(profiles_x), np.squeeze(profiles_y), np.squeeze(angles)    def upstream(self, name, cutoff=np.pi / 2):        """        Function to extract the l1 distance between consecutive upstream profiles to ensure they have converged        in time and space. In future this could be much more clever and have a cut off when the flow has        separated.        """        tmp = []        for idx, ang in enumerate(self.angles):            if ang <= cutoff:                tmp.append(name[idx])        return tmp    def bl_poincare_limit(self, single_point=True, position=0.1, length_scale=64, print_len=3, print_res=256):        """        Process the profile dat so the x and y components of profiles either as single point in        that profile or as a sum of the whole BL        all the parts to encompass the whole profile.        :param single_point: Whether the BL should by analysed as a single point or an integral over the                            the whole profile.        :param position: The percentage of the diameter the BL profile is evaluated at        :param length_scale: The length scale of the simulation        :param print_len: How many length scales away from the body centre the profiles print.        :param print_res: How many points are printed when the print function is called        :return: PoincarÃ© limit cycle at different angles around the profile.        """        from collections import deque        # Length of points depending on the resolution chosen for the print function        len_print = print_res / print_len        # The ratio between the print resolution and the actual grid spacing        len_res = print_res / (print_len * length_scale)        # About where the smoothing region ends in terms of the print resolution        eps = 2 * len_res        if single_point:            # Check if the evaluation point is at least 3 grid cells from the body boundary            eval_point = position * len_print  # This is the distance away from the body in terms of the print res            if eval_point < eps * 1.5:                raise ValueError("The evaluation point sits too close to the smoothing region,\                                    try adjusting the 'position' or increase your resolution")            else:                radial = []                azimuthal = []                for idx_angle, (loop_angle_x, loop_angle_y) in enumerate(zip(self.profiles_x, self.profiles_y)):                    tmp_r = []                    tmp_a = []                    for loop_time_x, loop_time_y in zip(loop_angle_x, loop_angle_y):                        # Index to the profile list rounded away from boundary to avoid smoothing region                        idx = math.ceil(eval_point)  # Idx in terms of print res                        vel = np.array((loop_time_x[idx], loop_time_y[idx]))                        theta = self.angles[idx_angle]                        rot = np.array(((np.cos(theta), -np.sin(theta)),                                        (np.sin(theta), np.cos(theta))))                        # Do you need to scale the velocities by the length scale? Check means.                        rad, az = rot.dot(vel)                        tmp_r.append(rad)                        tmp_a.append(az)                    radial.append(tmp_r)                    azimuthal.append(tmp_a)                dim_r = []                dim_a = []                for idx, (r, a) in enumerate(zip(list(radial), list(azimuthal))):                    dim_r.append(np.shape(r))                    dim_a.append(np.shape(a))                reshaped_r = []                reshaped_a = []                for idx, (r, a) in enumerate(zip(radial, azimuthal)):                    r = np.array(r)                    a = np.array(a)                    reshaped_r.append(r[0:min(dim_r)[0]])                    reshaped_a.append(a[0:min(dim_a)[0]])            return np.array(reshaped_r), np.array(reshaped_a)        else:            radial = []            azimuthal = []            for idx_angle, (loop_angle_x, loop_angle_y) in enumerate(zip(self.profiles_x, self.profiles_y)):                tmp_r = np.array([])                tmp_a = np.array([])                for loop_time_x, loop_time_y in zip(loop_angle_x, loop_angle_y):                    vel = np.array((loop_time_x, loop_time_y))                    theta = self.angles[idx_angle]                    rot = np.array(((np.cos(theta), -np.sin(theta)),                                    (np.sin(theta), np.cos(theta))))                    rad, az = rot.dot(vel)                    tmp_r = np.append(tmp_r, rad)                    tmp_a = np.append(tmp_a, az)                radial.append(tmp_r)                azimuthal.append(tmp_a)            return radial, azimuthal    def get_u(self, p, length_scale=64, print_len=3, print_res=256):        """        Extracts the point velocity at a distance n away from the hard body boundary            n: Number of points away from the body boundary            length_scale: User defined resolution            print_len: How long the profile extends for in terms of length scale            print_res: Resolution of printed profile using at function            eps: Size of the smoothing kernel        Returns:            First order finite difference at theta        """        # Find where the first point off the hard boundary is        ps = print_res / (print_len * length_scale)        u = []        v = []        for idx_angle, (loop_angle_x, loop_angle_y) in enumerate(zip(self.profiles_x, self.profiles_y)):            tmp_u = []            tmp_v = []            for time, (loop_time_x, loop_time_y) in enumerate(zip(loop_angle_x, loop_angle_y)):                # Point on the edge of the smoothing region (still kinda corrupt from smoothing within)                # Not always printed on an index so interpolate between                n = (0.5 * length_scale + p) * ps + 1e-7                x_vel = _interpolate(n, math.floor(n), math.ceil(n), loop_time_x[math.floor(n)],                                     loop_time_x[math.ceil(n)])                y_vel = _interpolate(n, math.floor(n), math.ceil(n), loop_time_y[math.floor(n)],                                     loop_time_y[math.ceil(n)])                tmp_u.append(x_vel)                tmp_v.append(y_vel)            u.append(tmp_u)            v.append(tmp_v)        return np.array(u), np.array(v)