# -*- coding: utf-8 -*-"""@author: J. Massey@description: Module to hold all the various convergence tests for a series of simulations. This    will provide the tools to show that a simulation has converged.@contact: jmom1n15@soton.ac.uk"""# Importsimport numpy as npfrom multiprocessing import Poolimport matplotlib.pyplot as pltimport osimport torchimport mathfrom tqdm import tqdmdevice = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")def _interpolate(x, x0, x1, y0, y1):    """    Quickly interpolate between two points    Args:    Returns:        Linear interpolation    """    return y0 + (x - x0) * (y1 - y0) / (x1 - x0)def plot_poincare(x, y, file, x_label, y_label, title=None, alpha=0.15, color='red', colours=None, label=None):    ax = plt.gca()    fig = plt.gcf()    ax.set_title(title)    # Loop so that lines get darker when they overlap    for i in range(len(x) - 1):        ax.plot_fill(x[i:i + 2], y[i:i + 2], alpha=alpha, color=color, solid_capstyle="butt")    ax.tick_params(bottom="on", top="on", right="on", which='both', direction='in', length=2)    # Edit frame, labels and legend    ax.set_xlabel(x_label)    ax.set_ylabel(y_label)    # Make legend manually so that we don'torch try and label each line segment    from matplotlib.lines import Line2D    legend_elements = []    for idx, loop in enumerate(label):        legend_elements.append(Line2D([0], [0], color=colours[idx], lw=4, label=loop))    ax.legend(handles=legend_elements, loc='lower right')    # Show plot and save figure    plt.savefig(file, transparent=False, bbox_inches='tight')    returnclass ProfileDataset:    """    This class takes an input of a convergence test directory and returns the resolution,    angle around the circle, a list of the velocities at discrete spacings. And the l1    distance between consecutive profiles.    For this class to work your simulation folders must be structured as:    |+-- vtr_file    |   +-- profiles    Where the profiles subdirectory will have been printed using the all_profiles function in    utils.f90. These should be printed as consecutive x and Y components e.g.:    ```    call all_profile(ave_v0%e(1), 256, 4.*length_scale, angle)    call all_profile(ave_v0%e(2), 256, 4.*length_scale, angle)    ```    """    def __init__(self, data_root, **kwargs):        self.profiles_folder = os.path.join(data_root, 'profiles')        self.conditions = []        # self.step_angle = np.pi / len(os.listdir(self.profiles_folder))        self.print_res = kwargs.get('print_res', 128)        multi = kwargs.get('multi', 1)        try:            self.profiles = self.multi_core_profiles(os.listdir(self.profiles_folder), multi)            self.profiles = np.nan_to_num(self.profiles)        except FileNotFoundError:            print('No profiles')    def _profiles(self, f_list):        profiles = []        for idx, angle in tqdm(enumerate(f_list), desc='Profile fn loop', ascii=True):            angle_file = os.path.join(self.profiles_folder, angle)            profile = np.genfromtxt(angle_file)            profiles.append(profile)        del profile        return np.stack(profiles, axis=0)    def multi_core_profiles(self, f_list, proc):        chunks = [f_list[i::proc] for i in range(proc)]        with Pool(processes=proc) as p:            if proc > 1:                profiles = np.concatenate(p.map(self._profiles, chunks))            else:                profiles = np.squeeze(p.map(self._profiles, chunks))        return profiles    def bl_value(self, single_point=True, position=0.1, length_scale=64, print_len=3):        """        Process the profile dat so the x and Y components of profiles either as single point in        that profile or as a sum of the whole BL        all the parts to encompass the whole profile.        :param single_point: Whether the BL should by analysed as a single point or an integral over the                            the whole profile.        :param position: The percentage of the diameter the BL profile is evaluated at        :param length_scale: The length scale of the simulation        :param print_len: How many length scales away from the body centre the profiles print.        :return: Poincar√© limit cycle at different angles around the profile.        """        from collections import deque        # Length of points depending on the resolution chosen for the print function        len_print = self.print_res / print_len        # The ratio between the print resolution and the actual grid spacing        len_res = self.print_res / (print_len * length_scale)        # About where the smoothing region ends in terms of the print resolution        eps = 2 * len_res        if single_point:            # Check if the evaluation point is at least 3 grid cells from the body boundary            eval_point = position * len_print  # This is the distance away from the body in terms of the print res            if eval_point < eps * 1.1:                raise ValueError("The evaluation point sits too close to the smoothing region,\                                    try adjusting the 'position' or increase your resolution")            else:                azimuthal = []                for idx_angle, (loop_angle) in enumerate(self.profiles):                    tmp_r = []                    tmp_a = []                    for loop_time in loop_angle:                        # Index to the profile list rounded away from boundary to avoid smoothing region                        idx = math.ceil(eval_point)  # Idx in terms of print res                        vel = np.array(loop_time[idx][idx])                        tmp_a.append(vel)                    azimuthal.append(tmp_a)                dim_a = []                for idx, (r, a) in enumerate(list(azimuthal)):                    dim_a.append(np.shape(a))                reshaped_a = []                for idx, (r, a) in enumerate(azimuthal):                    a = np.array(a)                    reshaped_a.append(a[0:min(dim_a)[0]])            return np.array(reshaped_a)        else:            azimuthal = []            for idx_angle, (loop_angle) in enumerate(self.profiles):                tmp_a = np.array([])                for loop_time in zip(loop_angle):                    vel = np.array(loop_time)                    tmp_a = np.append(tmp_a, vel)                azimuthal.append(tmp_a)            return azimuthal    def get_s(self, p, length_scale=64, print_len=3, down=1):        """        Extracts the point velocity at a distance n away from the hard body boundary            p: Number of points away from the body boundary            length_scale: User defined resolution            print_len: How long the profile extends for in terms of length scale            down: A ratio to subsample the profile        Returns:            Point velocity p grid_cells from the boundary        """        # Find where the first point off the hard boundary is        ps = self.print_res / (print_len / down * length_scale)        s = np.empty(np.shape(self.profiles)[:-1])        n = (0.5 * length_scale + p) * ps + 1e-9        for idx_angle, loop_angle in enumerate(self.profiles[:, :, ::down]):            for time, loop_time_x in enumerate(loop_angle):                # Point on the edge of the smoothing region (still kinda corrupt from smoothing within)                # Not always printed on an index so interpolate between                s[idx_angle, time] = _interpolate(n, math.floor(n), math.ceil(n), loop_time_x[math.floor(n)],                                                  loop_time_x[math.ceil(n)])        return sif __name__ == "__main__":    data_root_ = '/home/masseyjmo/Workspace/Lotus/projects/cylinder_dns/data'    d = ProfileDataset(os.path.join(data_root_, '96', '3D'), multi=16)    print(np.shape(d))